
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/pretrained_models.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_pretrained_models.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_pretrained_models.py:


Using pretrained models
=======================
This tutorial explains how to use pretrained models in TorchRL.

.. GENERATED FROM PYTHON SOURCE LINES 8-16

At the end of this tutorial, you will be capable of using pretrained models
for efficient image representation, and fine-tune them.

TorchRL provides pretrained models that are to be used either as transforms or as
components of the policy. As the sematic is the same, they can be used interchangeably
in one or the other context. In this tutorial, we will be using R3M (https://arxiv.org/abs/2203.12601),
but other models (e.g. VIP) will work equally well.


.. GENERATED FROM PYTHON SOURCE LINES 16-25

.. code-block:: default

    import torch.cuda
    from tensordict.nn import TensorDictSequential
    from torch import nn
    from torchrl.envs import R3MTransform, TransformedEnv
    from torchrl.envs.libs.gym import GymEnv
    from torchrl.modules import Actor

    device = "cuda:0" if torch.cuda.device_count() else "cpu"








.. GENERATED FROM PYTHON SOURCE LINES 26-30

Let us first create an environment. For the sake of simplicity, we will be using
a common gym environment. In practice, this will work in more challenging, embodied
AI contexts (e.g. have a look at our Habitat wrappers).


.. GENERATED FROM PYTHON SOURCE LINES 30-32

.. code-block:: default

    base_env = GymEnv("Ant-v4", from_pixels=True, device=device)








.. GENERATED FROM PYTHON SOURCE LINES 33-40

Let us fetch our pretrained model. We ask for the pretrained version of the model through the
download=True flag. By default this is turned off.
Next, we will append our transform to the environment. In practice, what will happen is that
each batch of data collected will go through the transform and be mapped on a "r3m_vec" entry
in the output tensordict. Our policy, consisting of a single layer MLP, will then read this vector and compute
the corresponding action.


.. GENERATED FROM PYTHON SOURCE LINES 40-47

.. code-block:: default

    r3m = R3MTransform("resnet50", in_keys=["pixels"], download=True).to(device)
    env_transformed = TransformedEnv(base_env, r3m)
    net = nn.Sequential(
        nn.LazyLinear(128), nn.Tanh(), nn.Linear(128, base_env.action_spec.shape[-1])
    )
    policy = Actor(net, in_keys=["r3m_vec"])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading: "https://pytorch.s3.amazonaws.com/models/rl/r3m/r3m_50.pt" to /github/home/.cache/torch/hub/checkpoints/r3m_50.pt
      0%|          | 0.00/374M [00:00<?, ?B/s]      0%|          | 312k/374M [00:00<02:38, 2.48MB/s]      1%|          | 2.58M/374M [00:00<00:28, 13.7MB/s]      2%|2         | 8.40M/374M [00:00<00:11, 33.3MB/s]      4%|3         | 14.7M/374M [00:00<00:08, 45.5MB/s]      6%|5         | 21.1M/374M [00:00<00:06, 52.9MB/s]      7%|7         | 27.5M/374M [00:00<00:06, 57.7MB/s]      9%|9         | 34.0M/374M [00:00<00:05, 61.1MB/s]     11%|#         | 40.3M/374M [00:00<00:05, 62.6MB/s]     13%|#2        | 46.8M/374M [00:00<00:05, 64.3MB/s]     14%|#4        | 53.4M/374M [00:01<00:05, 65.3MB/s]     16%|#6        | 60.1M/374M [00:01<00:04, 66.8MB/s]     18%|#7        | 66.7M/374M [00:01<00:04, 67.8MB/s]     20%|#9        | 73.6M/374M [00:01<00:04, 68.9MB/s]     22%|##1       | 80.5M/374M [00:01<00:04, 70.0MB/s]     23%|##3       | 87.4M/374M [00:01<00:04, 70.9MB/s]     25%|##5       | 94.3M/374M [00:01<00:04, 71.1MB/s]     27%|##7       | 101M/374M [00:01<00:03, 72.2MB/s]      29%|##8       | 108M/374M [00:01<00:03, 72.7MB/s]     31%|###       | 115M/374M [00:01<00:03, 73.0MB/s]     33%|###2      | 123M/374M [00:02<00:03, 73.5MB/s]     35%|###4      | 130M/374M [00:02<00:03, 73.9MB/s]     37%|###6      | 137M/374M [00:02<00:03, 74.7MB/s]     39%|###8      | 144M/374M [00:02<00:03, 75.0MB/s]     41%|####      | 152M/374M [00:02<00:03, 75.4MB/s]     42%|####2     | 159M/374M [00:02<00:02, 76.1MB/s]     44%|####4     | 166M/374M [00:02<00:02, 76.5MB/s]     46%|####6     | 174M/374M [00:02<00:02, 77.0MB/s]     48%|####8     | 181M/374M [00:02<00:02, 77.6MB/s]     51%|#####     | 189M/374M [00:02<00:02, 78.7MB/s]     53%|#####2    | 197M/374M [00:03<00:02, 78.8MB/s]     55%|#####4    | 204M/374M [00:03<00:02, 79.0MB/s]     57%|#####6    | 212M/374M [00:03<00:02, 78.9MB/s]     59%|#####8    | 220M/374M [00:03<00:02, 79.7MB/s]     61%|######    | 227M/374M [00:03<00:01, 80.3MB/s]     63%|######2   | 235M/374M [00:03<00:01, 81.0MB/s]     65%|######4   | 243M/374M [00:03<00:01, 81.1MB/s]     67%|######7   | 251M/374M [00:03<00:01, 81.8MB/s]     69%|######9   | 259M/374M [00:03<00:01, 81.2MB/s]     71%|#######1  | 267M/374M [00:03<00:01, 82.0MB/s]     73%|#######3  | 275M/374M [00:04<00:01, 82.0MB/s]     76%|#######5  | 283M/374M [00:04<00:01, 82.7MB/s]     78%|#######7  | 291M/374M [00:04<00:01, 82.9MB/s]     80%|#######9  | 299M/374M [00:04<00:01, 74.5MB/s]     82%|########1 | 307M/374M [00:04<00:00, 77.0MB/s]     84%|########3 | 314M/374M [00:04<00:00, 75.0MB/s]     86%|########6 | 322M/374M [00:04<00:00, 78.0MB/s]     88%|########8 | 330M/374M [00:04<00:00, 80.0MB/s]     90%|######### | 338M/374M [00:04<00:00, 81.5MB/s]     93%|#########2| 347M/374M [00:04<00:00, 82.5MB/s]     95%|#########4| 355M/374M [00:05<00:00, 83.2MB/s]     97%|#########7| 363M/374M [00:05<00:00, 83.8MB/s]     99%|#########9| 371M/374M [00:05<00:00, 84.1MB/s]    100%|##########| 374M/374M [00:05<00:00, 73.6MB/s]




.. GENERATED FROM PYTHON SOURCE LINES 48-50

Let's check the number of parameters of the policy:


.. GENERATED FROM PYTHON SOURCE LINES 50-52

.. code-block:: default

    print("number of params:", len(list(policy.parameters())))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of params: 4




.. GENERATED FROM PYTHON SOURCE LINES 53-55

We collect a rollout of 32 steps and print its output:


.. GENERATED FROM PYTHON SOURCE LINES 55-58

.. code-block:: default

    rollout = env_transformed.rollout(32, policy)
    print("rollout with transform:", rollout)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    rollout with transform: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 59-63

For fine tuning, we integrate the transform in the policy after making the parameters
trainable. In practice, it may be wiser to restrict this to a subset of the parameters (say the last layer
of the MLP).


.. GENERATED FROM PYTHON SOURCE LINES 63-67

.. code-block:: default

    r3m.train()
    policy = TensorDictSequential(r3m, policy)
    print("number of params after r3m is integrated:", len(list(policy.parameters())))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of params after r3m is integrated: 163




.. GENERATED FROM PYTHON SOURCE LINES 68-72

Again, we collect a rollout with R3M. The structure of the output has changed slightly, as now
the environment returns pixels (and not an embedding). The embedding "r3m_vec" is an intermediate
result of our policy.


.. GENERATED FROM PYTHON SOURCE LINES 72-75

.. code-block:: default

    rollout = base_env.rollout(32, policy)
    print("rollout, fine tuning:", rollout)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    rollout, fine tuning: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    pixels: Tensor(shape=torch.Size([32, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 76-83

The easiness with which we have swapped the transform from the env to the policy
is due to the fact that both behave like TensorDictModule: they have a set of `"in_keys"` and
`"out_keys"` that make it easy to read and write output in different context.

To conclude this tutorial, let's have a look at how we could use R3M to read
images stored in a replay buffer (e.g. in an offline RL context). First, let's build our dataset:


.. GENERATED FROM PYTHON SOURCE LINES 83-88

.. code-block:: default

    from torchrl.data import LazyMemmapStorage, ReplayBuffer

    storage = LazyMemmapStorage(1000)
    rb = ReplayBuffer(storage=storage, transform=r3m)








.. GENERATED FROM PYTHON SOURCE LINES 89-92

We can now collect the data (random rollouts for our purpose) and fill the replay
buffer with it:


.. GENERATED FROM PYTHON SOURCE LINES 92-98

.. code-block:: default

    total = 0
    while total < 1000:
        tensordict = base_env.rollout(1000)
        rb.extend(tensordict)
        total += tensordict.numel()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Creating a MemmapStorage...
    The storage is being created: 
            action: /tmp/tmpvyumn9fv, 0.030517578125 Mb of storage (size: torch.Size([1000, 8])).
            done: /tmp/tmpwqlh757u, 0.00095367431640625 Mb of storage (size: torch.Size([1000, 1])).
            pixels: /tmp/tmp4gy0zazl, 659.1796875 Mb of storage (size: torch.Size([1000, 480, 480, 3])).
            reward: /tmp/tmp4lck14pj, 0.003814697265625 Mb of storage (size: torch.Size([1000, 1])).
            ('next', 'pixels'): /tmp/tmpxglt_dcn, 659.1796875 Mb of storage (size: torch.Size([1000, 480, 480, 3])).




.. GENERATED FROM PYTHON SOURCE LINES 99-101

Let's check what our replay buffer storage looks like. It should not contain the "r3m_vec" entry
since we haven't used it yet:

.. GENERATED FROM PYTHON SOURCE LINES 101-103

.. code-block:: default

    print("stored data:", storage._storage)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    stored data: TensorDict(
        fields={
            action: MemmapTensor(shape=torch.Size([1000, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: MemmapTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    pixels: MemmapTensor(shape=torch.Size([1000, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False)},
                batch_size=torch.Size([1000]),
                device=cpu,
                is_shared=False),
            pixels: MemmapTensor(shape=torch.Size([1000, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
            reward: MemmapTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
        batch_size=torch.Size([1000]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 104-107

When sampling, the data will go through the R3M transform, giving us the processed data that we wanted.
In this way, we can train an algorithm offline on a dataset made of images:


.. GENERATED FROM PYTHON SOURCE LINES 107-109

.. code-block:: default

    batch = rb.sample(32)
    print("data after sampling:", batch)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data after sampling: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    pixels: Tensor(shape=torch.Size([32, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  27.684 seconds)


.. _sphx_glr_download_tutorials_pretrained_models.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: pretrained_models.py <pretrained_models.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: pretrained_models.ipynb <pretrained_models.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
